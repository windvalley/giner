package midware

import (
	"errors"
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/gin-gonic/gin"

	"use-gin/api"
	"use-gin/auth"
	"use-gin/config"
	"use-gin/errcode"
)

// JWT Json Web Token, and used for /login and api signature.
func JWT() gin.HandlerFunc {
	// this jwtSecret is for /login, and the token is generated by server.
	jwtSecret := config.Conf().Auth.JWTSecret

	return func(c *gin.Context) {
		jwtToken, err := getTokenFromRequest(c)
		if err != nil {
			err1 := errcode.New(errcode.TokenInvalidError, nil)
			err1.Add(err)
			api.SendResponse(c, err1, nil)

			c.Abort()
			return
		}

		payloadSegment := strings.Split(jwtToken, ".")[1]
		payload, err := auth.GetPayload(payloadSegment)
		if err != nil {
			err1 := errcode.New(errcode.TokenInvalidError, err)
			err1.Add("JWT validation failed")
			api.SendResponse(c, err1, nil)

			c.Abort()
			return
		}

		if secret, ok := auth.GetSecretOfAppkey(payload.Issuer); ok {
			// this jwtSecret is for api auth, and the token is generated by client(user) side.
			jwtSecret = secret
			jwtMaxLifetime := config.Conf().Auth.JWTMaxLifetime
			if payload.ExpiresAt-time.Now().Unix() > jwtMaxLifetime {
				err := errcode.New(errcode.TokenInvalidError, nil)
				err.Add("'exp': 'exceeds maximum allowed expiration'")
				api.SendResponse(c, err, nil)

				c.Abort()
				return
			}
		}

		claims, err := auth.ParseJWT(jwtToken, jwtSecret)
		if err != nil {
			switch err.(*jwt.ValidationError).Errors {
			case jwt.ValidationErrorExpired:
				err1 := errcode.New(errcode.TokenInvalidError, err)
				err1.Add("JWT expired")
				api.SendResponse(c, err1, nil)
			case jwt.ValidationErrorSignatureInvalid:
				err1 := errcode.New(errcode.TokenInvalidError, err)
				err1.Add("JWT signature validation failed")
				api.SendResponse(c, err1, nil)
			default:
				err1 := errcode.New(errcode.TokenInvalidError, err)
				err1.Add("JWT validation failed")
				api.SendResponse(c, err1, nil)
			}

			c.Abort()
			return
		}

		// NOTE: handler function can be get username or appkey by c.Get("key")
		c.Set("key", claims.Issuer)

		c.Next()
	}
}

func getTokenFromRequest(c *gin.Context) (string, error) {
	jwtToken := c.Query("jwt")

	if jwtToken == "" {
		jwtToken = c.Query("token")
	}

	if jwtToken == "" {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			return "", errors.New("no JWT(Json Web Token) found")
		}

		values := strings.Split(authHeader, " ")
		if len(values) != 2 || values[0] != "Bearer" {
			return "", errors.New("Request header 'Authorization' format invalid")
		}
		jwtToken = values[1]
	}

	return jwtToken, nil
}
